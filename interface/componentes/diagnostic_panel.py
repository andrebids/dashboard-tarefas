# -*- coding: utf-8 -*-
"""
Componente de Painel de Diagn√≥sticos - Diagn√≥sticos do sistema Planka.
"""

import tkinter as tk
from tkinter import ttk, messagebox
import threading
from typing import Dict, Callable, Optional


class DiagnosticPanel:
    """
    Componente de painel de diagn√≥sticos.
    Respons√°vel pelos bot√µes de diagn√≥stico e √°rea de logs.
    """
    
    def __init__(self, parent, diagnostic_manager, log_manager, 
                 callback_adicionar_log: Optional[Callable] = None):
        """
        Inicializa o componente de painel de diagn√≥sticos.
        
        Args:
            parent: Widget pai
            diagnostic_manager: Inst√¢ncia do DiagnosticManager
            log_manager: Gerenciador de logs
            callback_adicionar_log: Callback para adicionar logs
        """
        self.parent = parent
        self.diagnostic_manager = diagnostic_manager
        self.log_manager = log_manager
        self.callback_adicionar_log = callback_adicionar_log
        
        # Thread para opera√ß√µes longas
        self.thread_operacao = None
        
        # Widgets
        self.btn_diagnostico_completo = None
        self.btn_diagnostico_rapido = None
        self.btn_forcar_reinicio = None
        self.text_logs = None
        
        self._criar_interface()
    
    def _criar_interface(self):
        """Cria a interface do painel de diagn√≥sticos."""
        # Frame principal
        self.frame_diagnosticos = ttk.LabelFrame(self.parent, text="Diagn√≥sticos", padding=20)
        self.frame_diagnosticos.pack(fill=tk.X, pady=(0, 20))
        
        # Frame para bot√µes de diagn√≥stico
        self.frame_botoes = ttk.Frame(self.frame_diagnosticos)
        self.frame_botoes.pack(fill=tk.X, pady=(0, 10))
        
        # Bot√£o Diagn√≥stico Completo
        self.btn_diagnostico_completo = ttk.Button(self.frame_botoes, text="üîß Diagn√≥stico Completo", 
                                                  command=self._diagnostico_completo)
        self.btn_diagnostico_completo.pack(side=tk.LEFT, padx=(0, 10))
        
        # Bot√£o Diagn√≥stico R√°pido
        self.btn_diagnostico_rapido = ttk.Button(self.frame_botoes, text="‚ö° Diagn√≥stico R√°pido", 
                                                command=self._diagnostico_rapido)
        self.btn_diagnostico_rapido.pack(side=tk.LEFT, padx=(0, 10))
        
        # Bot√£o For√ßar Reinicializa√ß√£o
        self.btn_forcar_reinicio = ttk.Button(self.frame_botoes, text="üîÑ For√ßar Reinicializa√ß√£o", 
                                             command=self._forcar_reinicializacao)
        self.btn_forcar_reinicio.pack(side=tk.LEFT, padx=(0, 10))
        
        # Frame para √°rea de logs
        self.frame_logs = ttk.LabelFrame(self.frame_diagnosticos, text="Logs de Diagn√≥stico", padding=10)
        self.frame_logs.pack(fill=tk.BOTH, expand=True)
        
        # √Årea de logs
        self.text_logs = tk.Text(self.frame_logs, height=8, font=("Consolas", 9),
                                bg="black", fg="white", wrap=tk.WORD)
        scrollbar = ttk.Scrollbar(self.frame_logs, orient="vertical", command=self.text_logs.yview)
        self.text_logs.configure(yscrollcommand=scrollbar.set)
        
        self.text_logs.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Configurar tags para cores
        self.text_logs.tag_configure("info", foreground="lightblue")
        self.text_logs.tag_configure("warning", foreground="yellow")
        self.text_logs.tag_configure("error", foreground="red")
        self.text_logs.tag_configure("success", foreground="lightgreen")
        
        # Frame de controles dos logs
        self.frame_controles_logs = ttk.Frame(self.frame_logs)
        self.frame_controles_logs.pack(fill=tk.X, pady=(10, 0))
        
        ttk.Button(self.frame_controles_logs, text="Limpar Logs", 
                  command=self._limpar_logs).pack(side=tk.LEFT)
    
    def _diagnostico_completo(self):
        """Executa um diagn√≥stico completo do Planka."""
        if self.thread_operacao and self.thread_operacao.is_alive():
            messagebox.showwarning("Aviso", "Opera√ß√£o em andamento. Aguarde...")
            return
        
        self.thread_operacao = threading.Thread(target=self._executar_diagnostico_completo)
        self.thread_operacao.daemon = True
        self.thread_operacao.start()
    
    def _executar_diagnostico_completo(self):
        """Executa o diagn√≥stico completo em thread separada."""
        try:
            self.log_manager.log_planka("INFO", "Iniciando diagn√≥stico completo...")
            self._adicionar_log("üîß Iniciando diagn√≥stico completo do Planka...", "info")
            
            # Limpar logs anteriores
            self._limpar_logs()
            
            # Executar diagn√≥stico detalhado
            self._adicionar_log("üìã Executando an√°lise completa do sistema...", "info")
            diagnostico = self.diagnostic_manager.diagnostico_detalhado()
            
            # 1. Mostrar depend√™ncias
            self._adicionar_log("\nüì¶ DEPEND√äNCIAS DO SISTEMA:", "info")
            for dep, status in diagnostico["dependencias"].items():
                icone = "‚úÖ" if status else "‚ùå"
                self._adicionar_log(f"  {icone} {dep.upper()}: {'Dispon√≠vel' if status else 'N√£o encontrado'}", 
                                  "success" if status else "error")
            
            # 2. Mostrar status do diret√≥rio
            self._adicionar_log("\nüìÅ DIRET√ìRIO DO PLANKA:", "info")
            if diagnostico["diretorio"]["valido"]:
                self._adicionar_log(f"  ‚úÖ Diret√≥rio v√°lido: {diagnostico['diretorio']['caminho']}", "success")
            else:
                self._adicionar_log(f"  ‚ùå Diret√≥rio inv√°lido: {diagnostico['diretorio']['caminho']}", "error")
            
            # 3. Mostrar processos Docker
            self._adicionar_log("\nüê≥ PROCESSOS DOCKER:", "info")
            if diagnostico["docker"]["processos"]:
                for processo in diagnostico["docker"]["processos"]:
                    self._adicionar_log(f"  üì¶ {processo['nome']}: {processo['status']}", "info")
            else:
                self._adicionar_log("  ‚ö†Ô∏è Nenhum processo Docker encontrado", "warning")
            
            # 4. Mostrar status geral
            self._adicionar_log("\nüåê STATUS GERAL:", "info")
            status_geral = diagnostico["status_geral"]
            if status_geral["status"] == "online":
                self._adicionar_log("  ‚úÖ Planka est√° online", "success")
                self._adicionar_log(f"  üìä Modo ativo: {status_geral['modo_ativo']}", "info")
            else:
                self._adicionar_log(f"  ‚ùå Planka est√° {status_geral['status']}", "error")
            
            # 5. Mostrar conectividade
            self._adicionar_log("\nüîå CONECTIVIDADE:", "info")
            conectividade = diagnostico["conectividade"]
            if conectividade.get("acessivel", False):
                self._adicionar_log(f"  ‚úÖ Acess√≠vel (HTTP {conectividade['status_code']})", "success")
            else:
                erro = conectividade.get("erro", "Desconhecido")
                self._adicionar_log(f"  ‚ùå N√£o acess√≠vel: {erro}", "error")
            
            # 6. Mostrar logs
            self._adicionar_log("\nüìù AN√ÅLISE DE LOGS:", "info")
            logs = diagnostico["logs"]
            if logs.get("disponivel", False):
                self._adicionar_log(f"  üìä Logs dispon√≠veis ({logs['tamanho']} caracteres)", "info")
                
                if logs.get("erros"):
                    self._adicionar_log("  ‚ö†Ô∏è Erros encontrados nos logs:", "warning")
                    for erro in logs["erros"]:
                        self._adicionar_log(f"    ‚Ä¢ {erro}", "error")
                else:
                    self._adicionar_log("  ‚úÖ Nenhum erro encontrado nos logs", "success")
            else:
                erro = logs.get("erro", "Desconhecido")
                self._adicionar_log(f"  ‚ùå N√£o foi poss√≠vel obter logs: {erro}", "error")
            
            # 7. Mostrar recursos (se dispon√≠vel)
            if "recursos" in diagnostico:
                self._adicionar_log("\nüíª RECURSOS DO SISTEMA:", "info")
                recursos = diagnostico["recursos"]
                if recursos.get("stats_disponivel", False):
                    self._adicionar_log("  üìä Estat√≠sticas de recursos dispon√≠veis", "info")
                    # Mostrar apenas as primeiras linhas das estat√≠sticas
                    linhas_stats = recursos["output"].split('\n')[:5]
                    for linha in linhas_stats:
                        if linha.strip():
                            self._adicionar_log(f"    {linha}", "info")
                else:
                    erro = recursos.get("erro", "Desconhecido")
                    self._adicionar_log(f"  ‚ö†Ô∏è Estat√≠sticas n√£o dispon√≠veis: {erro}", "warning")
            
            # 8. Relat√≥rio final
            self._adicionar_log("\nüìä RELAT√ìRIO FINAL", "info")
            
            problemas = diagnostico["problemas"]
            sugestoes = diagnostico["sugestoes"]
            
            if problemas:
                self._adicionar_log("  ‚ùå PROBLEMAS IDENTIFICADOS:", "error")
                for problema in problemas:
                    self._adicionar_log(f"    ‚Ä¢ {problema}", "error")
                
                self._adicionar_log("\nüí° SUGEST√ïES DE CORRE√á√ÉO:", "info")
                for sugestao in sugestoes:
                    self._adicionar_log(f"    ‚Ä¢ {sugestao}", "info")
                
                # Resumo
                self._adicionar_log(f"\nüìà RESUMO: {len(problemas)} problema(s) encontrado(s)", "warning")
            else:
                self._adicionar_log("  ‚úÖ SISTEMA FUNCIONANDO PERFEITAMENTE!", "success")
                self._adicionar_log("  üéâ Todos os componentes est√£o operacionais", "success")
            
            # 9. Informa√ß√µes adicionais
            self._adicionar_log(f"\n‚è∞ Diagn√≥stico executado em: {diagnostico['timestamp']}", "info")
            self._adicionar_log("üîß Diagn√≥stico completo finalizado!", "success")
            
            self.log_manager.log_planka("SUCCESS", "Diagn√≥stico completo finalizado")
            
        except Exception as e:
            self._adicionar_log(f"‚ùå Erro durante diagn√≥stico: {str(e)}", "error")
            self.log_manager.log_planka("ERROR", f"Erro durante diagn√≥stico: {e}")
    
    def _diagnostico_rapido(self):
        """Executa um diagn√≥stico r√°pido do Planka."""
        if self.thread_operacao and self.thread_operacao.is_alive():
            messagebox.showwarning("Aviso", "Opera√ß√£o em andamento. Aguarde...")
            return
        
        self.thread_operacao = threading.Thread(target=self._executar_diagnostico_rapido)
        self.thread_operacao.daemon = True
        self.thread_operacao.start()
    
    def _executar_diagnostico_rapido(self):
        """Executa diagn√≥stico r√°pido focado em problemas comuns."""
        try:
            self.log_manager.log_planka("INFO", "Iniciando diagn√≥stico r√°pido...")
            self._adicionar_log("‚ö° Iniciando diagn√≥stico r√°pido...", "info")
            
            # Limpar logs anteriores
            self._limpar_logs()
            
            # Executar diagn√≥stico r√°pido
            resultado = self.diagnostic_manager.diagnostico_rapido()
            
            problemas_encontrados = resultado["problemas"]
            sugestoes = resultado["sugestoes"]
            
            # Relat√≥rio final
            self._adicionar_log("\nüìä RELAT√ìRIO R√ÅPIDO", "info")
            
            if problemas_encontrados:
                self._adicionar_log("  ‚ùå PROBLEMAS ENCONTRADOS:", "error")
                for problema in problemas_encontrados:
                    self._adicionar_log(f"    ‚Ä¢ {problema}", "error")
                
                self._adicionar_log("\nüí° SUGEST√ïES:", "info")
                for sugestao in sugestoes:
                    self._adicionar_log(f"    ‚Ä¢ {sugestao}", "info")
                
                self._adicionar_log(f"\nüìà Total: {len(problemas_encontrados)} problema(s)", "warning")
            else:
                self._adicionar_log("  ‚úÖ Nenhum problema cr√≠tico encontrado!", "success")
                self._adicionar_log("  üí° Se o Planka ainda n√£o carrega, aguarde alguns minutos", "info")
            
            self._adicionar_log("\n‚ö° Diagn√≥stico r√°pido finalizado!", "success")
            self.log_manager.log_planka("SUCCESS", "Diagn√≥stico r√°pido finalizado")
            
        except Exception as e:
            self._adicionar_log(f"‚ùå Erro durante diagn√≥stico r√°pido: {str(e)}", "error")
            self.log_manager.log_planka("ERROR", f"Erro durante diagn√≥stico r√°pido: {e}")
    
    def _forcar_reinicializacao(self):
        """For√ßa uma reinicializa√ß√£o completa do Planka."""
        if self.thread_operacao and self.thread_operacao.is_alive():
            messagebox.showwarning("Aviso", "Opera√ß√£o em andamento. Aguarde...")
            return
        
        # Confirmar a√ß√£o
        if messagebox.askyesno("For√ßar Reinicializa√ß√£o", 
                              "Deseja for√ßar uma reinicializa√ß√£o completa do Planka?\n\n"
                              "Isso ir√°:\n"
                              "‚Ä¢ Parar todos os containers\n"
                              "‚Ä¢ Limpar recursos Docker\n"
                              "‚Ä¢ Reiniciar o Planka\n\n"
                              "Esta opera√ß√£o pode demorar alguns minutos."):
            
            self.thread_operacao = threading.Thread(target=self._executar_forcar_reinicializacao)
            self.thread_operacao.daemon = True
            self.thread_operacao.start()
    
    def _executar_forcar_reinicializacao(self):
        """Executa a reinicializa√ß√£o for√ßada em thread separada."""
        try:
            self.log_manager.log_planka("INFO", "Iniciando reinicializa√ß√£o for√ßada...")
            self._adicionar_log("üîÑ Iniciando reinicializa√ß√£o for√ßada...", "info")
            
            # Limpar logs anteriores
            self._limpar_logs()
            
            # Executar reinicializa√ß√£o for√ßada
            sucesso, mensagem = self.diagnostic_manager.forcar_reinicializacao()
            
            if sucesso:
                self._adicionar_log("  ‚úÖ Reinicializa√ß√£o for√ßada conclu√≠da com sucesso!", "success")
                self._adicionar_log("  üí° Aguarde alguns minutos para o Planka estar totalmente dispon√≠vel", "info")
            else:
                self._adicionar_log(f"  ‚ùå Erro na reinicializa√ß√£o: {mensagem}", "error")
            
            self._adicionar_log("\nüîÑ Reinicializa√ß√£o for√ßada finalizada!", "success")
            self.log_manager.log_planka("SUCCESS", "Reinicializa√ß√£o for√ßada finalizada")
            
        except Exception as e:
            self._adicionar_log(f"‚ùå Erro durante reinicializa√ß√£o for√ßada: {str(e)}", "error")
            self.log_manager.log_planka("ERROR", f"Erro durante reinicializa√ß√£o for√ßada: {e}")
    
    def _limpar_logs(self):
        """Limpa os logs do painel de diagn√≥sticos."""
        if self.text_logs:
            self.text_logs.delete(1.0, tk.END)
    
    def _adicionar_log(self, mensagem: str, nivel: str = "info"):
        """
        Adiciona um log √† √°rea de texto.
        
        Args:
            mensagem: Mensagem a adicionar
            nivel: N√≠vel do log (info, warning, error, success)
        """
        if self.text_logs:
            try:
                import datetime
                timestamp = datetime.datetime.now().strftime("%H:%M:%S")
                log_entry = f"[{timestamp}] {mensagem}\n"
                
                # Agendar inser√ß√£o na thread principal
                self.frame_diagnosticos.after(0, lambda: self._inserir_log_ui(log_entry, nivel))
                
            except Exception as e:
                self.log_manager.log_sistema("ERROR", f"Erro ao adicionar log: {e}")
    
    def _inserir_log_ui(self, log_entry: str, nivel: str):
        """Insere log na UI (deve ser chamado na thread principal)."""
        try:
            self.text_logs.insert(tk.END, log_entry, nivel)
            self.text_logs.see(tk.END)
        except Exception as e:
            self.log_manager.log_sistema("ERROR", f"Erro ao inserir log na UI: {e}")
    
    def definir_callback_adicionar_log(self, callback: Callable):
        """
        Define o callback para adicionar logs.
        
        Args:
            callback: Fun√ß√£o a ser chamada para adicionar logs
        """
        self.callback_adicionar_log = callback
    
    def obter_widget(self) -> ttk.Frame:
        """
        Retorna o widget principal do componente.
        
        Returns:
            ttk.Frame principal
        """
        return self.frame_diagnosticos 